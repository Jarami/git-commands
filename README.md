## Основные команды Git:
```bash
# Инициализация репозитория:
$ git init

# Проверить состояние репозитория:
$ git status
$ git status --ignored # появляется дополнительный раздел Ignored files

# Подготовить файлы к сохранению (добавить в staged):
$ git add <file>
$ git add --all # добавляет всё
$ git add . # добавляет всё

# Выполнить коммит:
$ git commit -m "Some message"
$ git commit --amend --no-edit # добавляет к предыдущему комиту
$ git commit --amend -m "New message" # добавляет к предыдущему + изменяет сообщение

# Просмотреть историю коммитов:
$ git log
$ git log --oneline # компактный вывод

# Привязать удалённый репозиторий к локальному:
$ git remote add origin https://github.com/<account-name>/<repo-name>.git 

# Информация об удаленных репозиториях:
$ git remote -v 

# Отправить изменения на удалённый репозиторий:
$ git push -u origin main # только для первого push
$ git push

# Убрать файл из staging в untracked/modified:
$ git restore --staged <file>
$ git restore --staged . # убирает всё

# Убрать файл из modified (если случайно поменяли какой-то файл):
$ git restore <file>

# Откатить коммит (осторожно, откатить откат невозможно): 
$ git reset --hard <commit hash> # в <commit hash> указывается, куда нужно откатить

# Посмотреть изменения в файлах:
$ git diff
$ git diff --staged # показывает изменения в staged-файлах
$ git diff <commit hash A> <commit hash B> # что изменилось с A до B
$ git diff <название_ветки1> <название_ветки2>
$ git diff HEAD~1 HEAD # разница между предыдущим и текущим коммитом

# Ветки
$ git branch # посмотреть какие ветки есть и какая текущая
$ git branch <название_ветки> # создать ветку
$ git checkout <название_ветки> # переключиться на ветку
$ git checkout -b <название_ветки> # создать ветку и сразу переключиться на нее
$ git merge <название_ветки> # слить ветку <название_ветки> с текущей
$ git branch -D <название_ветки> # удалить ветку
```

## Статусы untracked/tracked, staged и modified
Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

**untracked** (англ. «неотслеживаемый»)\
Новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.

**staged** (англ. «подготовленный»)\
После выполнения команды ```git add``` файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.\
По аналогии с фотографией, команда ```git add``` добавляет персонажей (текущее содержимое файла или нескольких файлов) на сцену (англ. stage) для общей фотографии, а ```git commit``` делает снимок всей сцены целиком.

**tracked** (англ. «отслеживаемый»)\
Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью ```git commit```, а также файлы, которые были добавлены в staging area командой ```git add```. То есть все файлы, в которых Git так или иначе отслеживает изменения.

**modified** (англ. «изменённый»)\
Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

### Про staged и modified
Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете ```git add file.txt```, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.
Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить ```git add file.txt``` ещё раз.

## Типичный жизненный цикл файла в Git

![Типичный жизненный цикл файла в Git](lifecycle.png)

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: untracked.
1. Файл добавили в staging area с помощью ```git add```. Состояние: staged (+ tracked).
   * Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked).
   Обратите внимание: staged и modified у одного файла, но у разных его версий.
   * Ещё раз выполнили ```git add```. Состояние: staged (+ tracked).
1. Сделали коммит с помощью ```git commit```. Состояние: tracked.
1. Изменили файл. Состояние: modified (+ tracked).
1. Снова добавили в staging area с помощью ```git add```. Состояния: staged (+ tracked).
1. Сделали коммит. Состояния: tracked.
1. Повторили пункты 4−7 много-много раз.


## .gitignore

```bash
# игнорирование файла file.txt
file.txt 

# игнорировать все файлы, которые заканчиваются на .jpeg
*.jpeg

# но только не мем с Doge
!doge.jpeg 

# игнорировать все файлы "tmp" во всех подпапках папки docs
docs/*/tmp

# странное, но возможное правило
# "игнорировать все файлы"
* 

# игнорировать file<один символ>.txt (напр, file1.txt, но не file12.txt) 
file?.txt 

# игнорировать файлы file0.txt, file1.txt и file2.txt
# при этом не игнорировать file3.txt, file4.txt, ...
file[0-2].txt 

# игнорировать todo.txt в корне репозитория
/todo.txt

# для сравнения: spam.txt будет игнорироваться во всех папках
spam.txt 

# игнорировать папку build (но не файл build)
build/

# игнорировать файлы "docs/current/tmp", "docs/old/tmp",
# а также "docs/old/saved/a/b/c/d/tmp"
# и даже "docs/tmp", потому что ноль вложенных папок тоже подходит
docs/**/tmp

# игнорировать только "docs/current/tmp" и "docs/old/tmp"
# файл "docs/old/saved/a/b/c/d/tmp" не попадает в правило
docs/*/tmp 
```